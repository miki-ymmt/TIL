
学習時間　５h(1175h)
- ruby本
- paiza D問題、C問題
- アプリ開発　パスワードリセット


[学習を通して]
- パスワードリセットは流れを整理。バトランの時に一回実装しているのでnotionとreadmeを見返して明日実装終わらせたいです。
- マイページが不要な気がしてきました。。。元々プライベート使用なのでいらないかなと思ってます。indexも自分の旅しかないし...
- アカウント削除機能はまだつけてないけど、ヘッダーのメニューからでもいいかな？
- 繰り返し処理のところがもう少しで終わりそう。

添え字付きの繰り返し処理

each_with_indexメソッド

```jsx
fruits = ['apple', 'orange', 'melon']
fruits.each_with_index { |fruit, i| puts "#{i}: #{fruit}" }
#=> 0: apple
    1: otrange
    2: melon
```

- 配列をブロックパラメーターに渡す（複数の値）

```jsx
dimentions = [
  [10, 20],
  [30, 40],
  [50, 60],
]
#ブロックパラメータを()で囲んで、配列の要素を別々のパラメータとして受け取る
dimentions.each_with_index do |(length, width), i|
  puts "length: #{length}, width: #{width}, i: #{i}"
end
#=> length:10, width:20, i:0
    length:30, width:40, i:1
    length:50, width:60, i:2
    
    
```

- do…endと{}の結合度の違い

どちらを使っても結果は基本的には同じだが、do..endよりも{}の方が結合度が強い。

```jsx
⭕️ Rubyはメソッドの引数を含む（）を省略することができる
a.delete 100 do
  'NG'
end
#=> "NG"

❌
a.delete 100 { 'NG'}
#=> シンタックスエラー
{}の結合度が強いので、a.delete 100ではなく、１００{ 'NG' }と解釈されるため。
エラー解決のためには、１００を（）で囲む。そうすればa.delete(100)と優先的に解釈されるようになる。  
```

⭐️引数付きのメソッド呼び出しで{}をブロックとして使う場合は、メソッドの引数の（）を省略できない！

- ブロックの後ろに別メソッドを続けて書く

```jsx
names = ['田中', '鈴木', '佐藤']
names.map { |name| "#{name}さん" }.join('と') #=> "田中さんと鈴木さんと佐藤さん"

また{} と　do...endは基本的に同じなので,endの後ろにドットをつけてメソッドを呼び出すことができる

names = ['田中', '鈴木', '佐藤']
names.map do |name|
  "#{name}さん"
 end.join('と') #=> "田中さんと鈴木さんと佐藤さん"
```

- timesメソッド

配列を使わず、単純にn回処理を繰り返したい、という場合はintegerクラスのtimesメソッドを使うと便利。

```jsx
sum = 0
#処理を5回繰り返す。nには０,1,2,3,4が入る
5.times { |n| sum += n }
sum #=> 10
```

不要であればブロックパラメーターを省略してもOK

```jsx
sum = 0
#sumに１を加算する処理を5回繰り返す
5.times { sum += 1 }
sum #=> 5
```

- uptoメソッド

nからmまでの数値を一つずつ増やしながら何か処理をしたい場合はuptoメソッドを使う

```jsx
a = []
10.upto(14){ |n| a << n }
a #=> [10, 11, 12, 13, 14]
```

数を減らしたい場合はdowntoメソッドを使う

```jsx
a = []
14.downto(10) { |n| a << n }
a #=> [14, 13, 12, 11, 10]
```

- stepメソッド

1, 3, 5, 7のように、nからmまで数値をx個ずつ増やしながら処理をしたい場合はNumericクラスのstepメソッドを使う。

```jsx
開始値.step(上限値, 一度に増減する大きさ)
```

例えば、1~10まで２つずつ値を増やしながら処理したい場合

```jsx
a = []
1.step(10, 2) { |n| a << n }
a #=> [1, 3, 5, 7, 9]
```

10から1まで２つずつ値を減らす場合

```jsx
a = []
10.step(1, -2) { |n| a << n }
a #=> [10, 8, 6, 4, 2]
```

- while文

指定した条件が真である場合、処理を繰り返す

```jsx
while 条件式　（真であれば実行）
　　繰り返したい処理
end
```

```jsx
a = []
while a.size < 5
  a << １
end
a #=> [1, 1, 1, 1, 1]
```

条件式の後ろにdoを入れると１行で書くこともできる

```jsx
a = []
while a.size < 5 do a << 1 end
```

1行で書くなら修飾子としてwhile文を後ろに置いた方がスッキリする

```jsx
a = []
a << 1 while a.size < 5
a #=> [1, 1, 1, 1, 1]
```

- until文

```jsx
until 条件式　（偽であれば実行）
  繰り返したい処理
end
```

配列の要素が3以下になるまで配列の要素を後ろから排除する
```
a = [10, 20, 30, 40, 50]
until a.size <= 3
  a.delete_at(-1)
end
```

  
a #=> [10, 20, 30]
